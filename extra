static int rainhas_bt_(uint n, uint *cols, uint *diags2, uint *diags1, uint *mat, uint row, uint *r, uint sol_sz){
    // Caso base
    if (row == n){
        // Verificar se a solução até agora é a maior pois pode ser que seja
        // e quando voltar a chamada recursiva ela não vai ser salva
        // vide caso 5 com diagonais cortadas para entender
        if (sol_sz > maior_sol_bt_sz){
            maior_sol_bt_sz = sol_sz;
            memcpy(maior_sol_bt, r, n*sizeof(uint));
        }
        return sol_sz == n;
    }
    // Não desce se não tiver como melhorar
    // Nesse caso se não tiver mais linhas que somam
    // mais que a maior solução
    // OMG: A diferença que essa bomba faz, subiu o topo de uns 14 para 17
    if (sol_sz + n-row <= maior_sol_bt_sz)
        return 0;

    for (uint col = 0; col < n; col++){
        // 1. Se for uma casa proibida
        // 2. Se tiver uma rainha na coluna
        // 3. Se tiver uma rainha na diagonal principal
        // 4. Se tiver uma rainha na diagonal secundaria
        if (mat[row*n + col] == 1   ||
            cols[col] == 1          ||
            diags2[col + row] == 1  ||
            diags1[row-col+n-1] == 1)
            continue;

        // Coloca rainha na coluna e diagonais atual
        r[row] = col+1;
        cols[col] = diags2[row+col] = diags1[row-col+n-1] = 1;

        // Se achou retorna
        if (rainhas_bt_(n, cols, diags2, diags1, mat, row+1, r, sol_sz+1) == 1)
            return 1;

        r[row] = 0;
        // Se não faz o backtaking
        cols[col] = diags2[row+col] = diags1[row-col+n-1] = 0;
    }
    /* for (int i = 0; i < n; i++) */
    /*     printf("%d ", r[i]); */
    /* printf("\n"); */
    // Salva maior sequencia até agora
    if (sol_sz > maior_sol_bt_sz){
        maior_sol_bt_sz = sol_sz;
        memcpy(maior_sol_bt, r, n*sizeof(uint));
    }
    // Não conseguiu colocar nessa linha, tenta colocar na proxima
    // É nessario para casos de uma linha inteira coberta ou em que a recursão
    // para sem chegar no caso base (row == n)
    return rainhas_bt_(n, cols, diags2, diags1, mat, row+1, r, sol_sz);
}

unsigned int *rainhas_bt(unsigned int n, unsigned int k, casa *c, unsigned int *r) {
    // Vetor de colunas:
    //      cols[i] == 1: se tem rainha na coluna i
    //      cols[i] == 0: c.c
    uint *cols = calloc(n, (sizeof (uint)));

    // Matriz de casas proibidas (indexada por i*n + j):
    //      mat[i*n+j] == 1: se casa é proibida
    //      mat[i*n+j] == 0: c.c
    uint *mat  = calloc(n*n, (sizeof (uint)));
    for (uint i = 0; i < k; i++)
        mat[(c[i].linha-1)*n + c[i].coluna-1] = 1;

    // Vetor de diagonal secundaria:
    //      diags2[i] == 1: Se tem rainha na diagonal secundaria
    //      diags2[i] == 0: c.c
    // Fórmula de indexação (dado linha i e coluna j):
    //      diag = i + j
    uint *diags2  = calloc(2*n, (sizeof (uint)));

    // Vetor de diagonal principal:
    //      diags1[i] == 1: Se tem rainha na diagonal principal
    //      diags1[i] == 0: c.c
    // Fórmula de indexação (dado linha i e coluna j):
    //      diag = i - j + n - 1
    uint *diags1  = calloc(2*n, (sizeof (uint)));

    // Vetor de maior sequencia, guarda a maior sequencia
    // em caso de não ter solução o problema
    maior_sol_bt = calloc(n, (sizeof (uint)));

    if (!rainhas_bt_(n, cols, diags2, diags1, mat, 0, r, 0))
        memcpy(r, maior_sol_bt, n*sizeof(uint));

    free(cols);
    free(diags1);
    free(diags2);
    free(mat);
    free(maior_sol_bt);

    return r;
}